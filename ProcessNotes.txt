1. The __init__.py means the website folder is a python package and allows us to import anything from into somewhere else.
2. Flask is lightweight python framework that allows you to make website very quickly and easily. to install run two commands: 'pip install flask' and 'pip install flask-login'
3. Configure your init.py file as shown
4. Configure main.py file. 
5. setup the routes for the website. Go to the views.py file and import Blueprint (this allows everything to be organized neatly) then write the "views = Blueprint.." command. Repeat this also for the auth file as per shown.
6. Then add your url paths for each page you need.
7. Register each page and Blueprint in the init.py file. When you register the blueprints, whatever you set the url prefix to will prefix the actual url you set in the views/auth files. 
8. in your auth.py file define the routes for each of the pages which will be associated with the authentication process (i.e. login, logout and signup)
9. next is the templates folder. This is used for the html that is going to be displayed for each page. We use a framework call Jinja to help us run python without our html pages rather than javascript. When reading documentation, you need to focus on the Template Designer Documentation.
10. Create a base.html file which is going to act as the bases for all future templates. In here, initialize the html and add in your bootstrap links (both for the css and javascript). Here you are going to use "Blocks" - these are sections which can be overridden by a child template. Learn about blocks here: https://jinja.palletsprojects.com/en/stable/templates/#base-template
11. Anything that does not change, (i.e. images, css or javascript files) are put inside of the static folder. You then load them into your base.html file using a particular script. this is put at the bottom of the body:

    <script>
        type="text/javascript"
        src="{{ url_for('static', filename='index.js') }}"   --> this tells us to pull the url for the site when it is live, and look for the "static" folder. Then in there is a file call index.js. The squiggly brackets allow for us to write python. 
    </script>

12. Next you build out things like your navbar using standard bootstrap
13. Then create your child template. Starting with the extend syntax. See:https://jinja.palletsprojects.com/en/stable/templates/#child-template
14. once the child template is defined, you have to render it so it can be seen on the screen. Go to view.py, import the render_template function from Flask and then change the route to return the newly defined template . 
15. whenever you are importing or want to use flask, you have to include is an imported item. 
16. Once the page is rendering the appropriate, you can continue to use blocks to add page specific content. If the view is authentication orientated page, done in auth.py. If it is a standard view, then view.py. 
17. To pass a variable through to be displayed in the front, you have initialise it in the view.py/auth.py files. To then render that in the template, you have to use two squiggly brackets like below:

{{ text }}

18. To do an if statement it is as follows:

{% if boolean == True %}
    This variable is True
{% endif %}

You have your if/else (python) is squiggly and percent signs and then the content to display in those scenarios is contained within. 


[19 Minutes In]

18. Need to tell each of the end points which HTTP Requests they accept by adding the information to the auth.py files.
19. when configuring the form, it is the name attribute which helps the post request know what label to assign to the data in the database. 
20. for displaying success and error messages we use the Flash function. if there are different messages and different scenarios, we use the flash with categories: https://flask.palletsprojects.com/en/stable/patterns/flashing/#simple-flashing. You can us the IF and Else clauses to show different messages with different categories. Note also you can loop through two arrays at the same time and then check each one at different points in the if statement:


        {% with messages = get_flashed_messages(with_categories=true) %} 
            {% if messages %} 
            {% for category, message in messages %} 
                {% if category =='error' %}
                <div class="alert alert-danger alter-dismissable fade show" role="alert">
                {{ message }}
                <button type="button" class="close" data-dismiss="alert">
                    <span aria-hidden="true">&times;</span>
                </button>
                </div>
            {% else %}
            <div class="alert alert-success alter-dismissable fade show" role="alert">
            {{ message }}
            <button type="button" class="close" data-dismiss="alert">
                <span aria-hidden="true">&times;</span>
            </button>
            </div>
            {% endif %} {% endfor %} {% endif %} {% endwith %}


ESTABLISHING THE DATABASE 

This tutorial is great: https://www.geeksforgeeks.org/python/connect-flask-to-a-database-with-flask-sqlalchemy/ 

1. in the __init__.py file, import you flask_sqlalchemy and initialise the database:

        from flask_sqlalchemy import SQLAlchemy

        db = SQLAlchemy()
        DB_Name = "database.db"

2. tell the flask application (__init__.py file) where the database is located for future queries to and from said database:

    app.config['SQLALCHEMY_DATABASE_URI'] = f'sqlite:///{DB_Name}'
    db.init_app(app)

3. You then need to define the schema for the database. this is done in he models.py file. You have to import from the package (which is represented by a single dot) the database. If you are outside of the directory, you will replace the dot with the site you are importing from. So simply writing:

    from . import db

4. Also need to import the flask_login package which helps manage who can access these database. 
5. Define the columns for the different tables of data you want to store. you also, as with any database, need to define the data type and lengths that can be stored in that column:

        class User(db.Model, UserMixin):
            id = db.Column(db.Integer, primary_key=True)
            email = db.Column(db.String(150), unique=True)
            password = db.Column(db.String(150))
            first_name = db.Column(db.String(150))

6. After the tables are established, you have to associate each note with a user. You use foreign key to do this. This is a column in your database which always references another column in another database. To reference another database in the directory, simply write nameOfDatabase.columnName
If it is a one to many relationship (each user has many notes) you typically want to put the foreign key on the many item (in this case notes). You also want to reference the primary_key column. When referencing foreign key, the database name should start with lower case

Then you need to add a column which contains a list of all of the notes associated with that database. This is done by:

    notes = db.relationship('Note')

7. Then in the __init__.py file, you have to import and initialise the database during the program start-up. Write a function for the initialisation and call it after importing the models you have defined. 

        ...refix='/')
        
        import .models
        
        create_database(app)
        
        return app

def create_database(app):
    if not path.exists('website/' + DB_Name):
        with app.app_context():
            db.create_all()
        print('Database Created!') ----> note that with newer versions of flask, you have to do use the with function. 

CREATING USERS

1. To create a new user, in the auth.py file, under the if elseif tree, where the user has successfully entered the appropriate criteria, add the following:

    new_user = User(email=email, first_name=first_name, password=generate_password_hash(password1, method='sha256'))
    db.session.add(new_user) --> this establishes the user and then the second line commits it the database. 
    b.session.commit()

to access the database fields, you have to import the database:

    from .models import User

2. You also need to import the flask_login functionality and apply. You also need to import a password hasher to encrypt and decrypt passwords:

    from werkzeug.security import generate_password_hash, check_password_hash

3. Lastly after the user has created the database, we need to take them to the home page so their experience makes sense. use the flask redirect and url_for bahaviors to do this. Again these need to be imported first. 

4. Now users can sign-up you have to authenticate the user when signing in. This is done by (note that you do not need to provide the hashing method again):

    if request.method == 'POST':
        email = request.form.get('email')
        password = request.form.get('password1')
        
        user = User.query.filter_by(email=email).first()
        if user:
            if check_password_hash(user.password, password):
                flash('Logged in successfully!', category='success')
                return redirect(url_for('views.home'))
            else:
                flash('Incorrect password, try again.', category='error')
        else:
            flash('Email does not exist.', category='error')

5. Once a user is logged in, they should see certain things, and then when they are logged out, they should see certain things. This is done with the flask_login module. https://flask-login.readthedocs.io/en/latest/
In your auth.py login function, after the user has been authenticated, add the following line. You will also want to add the same for after a user has correctly signed-up

        login_user(user, remember=True)

6. For logout, for that end point, add the following. The @login_required ensure someone cannot access that page unless they had logged in. 

            @auth.route('/logout')
            @login_required
            def logout()
                logout_user()
                return render_template("logout.html")

    similarly, in the views.py file, you need to add a login_required to ensure no one can get there unless they are logged into the system. 

7. Lastly, to help us know who the logged in user is and to have their credentials to hand. This is done with the login manager, first import to your init file

from flask_login import LoginManager

8. then after the database is initialised within the file, add the following 
    
    Login_manager = LoginManager()
    Login_manager.login_view = 'auth.login'
    Login_manager.init_app(app)


9. To know if a user is logged in or not, and to then use this to control what they do and do not see, we use the current_user module from flask_login. In your views.py file, pass the the current_user as a variable into the view so i can be called on. 

        ... home():
    return render_template("home.html", user = current_user)

    Then, in your base template for example, you can use an if statement to check if the user is logged in and then show specific content:
        
        ...
        <div class="collapse navbar-collapse" id="navbar">
        <div class="navbar-nav">
          {% if current_user.is_authenticated %}
          <a class="nav-item nav-link" id="home" href="/">Home</a>
          <a class="nav-item nav-link" id="logout" href="/logout">Logout</a>
          {% else %}
          <a class="nav-item nav-link" id="login" href="/login">Login</a>
          <a class="nav-item nav-link" id="signup" href="/sign-up">Sign Up</a>
          {% endif %}

    Another example of accessing the data associated with a user is via: 

            <ul class="list-group list-group-flush" id="notes">
            {% for note in user.notes %}
                <li class = "list-group-item">{% note.data %}</li>
            {% endfor %}
            </ul>

9. NOTE:

 {% ... %} (The Percent Sign): This is for Logic/Statements. Jinja expects a command like if, for, else, or endfor. When you put {% note %}, Jinja thinks you are trying to start a new logic block called "note," which doesn't exist.

{{ ... }} (The Double Curly Braces): This is for Expressions/Data. This is what you use when you want to actually "print" or display the content of a variable to the screen.

10. If you ever have a button which needs to execute a post or get request to a database, you cannot do this exclusively with python. Only with a form, is it possible because the form handled the javascript required to make the post request. Other buttons require you to write the javascript yourself.
To do this, in the respective file, add the button and call a javascript function for the behavior. You will need to pass in the id of the object you are going to manipulate:

This video explains more: https://www.youtube.com/watch?v=b7GBRDJyZ3E&t=18s 

            <ul class="list-group list-group-flush" id="notes">
                {% for note in user.notes %}
                <li class = "list-group-item">{{ note.data }}
                    <button type="button" class="close" onClick = "deleteNote('{{ note.id }}')">
                        span aria-hidden = "true">&times;</span>
                    </button>
                </li>
                {% endfor %}
            </ul>
    Then, in the index.js file, which should be referenced a script in the base html page, add the following to make the fetch request to your custom end-point.
    The end-point is then configured in the view.py file to handle the fetch request and update the data.

        function deleteNote(noteId) {
            fetch('/delete-note', {
                method: 'POST',
                body: JSON.stringify({ noteId: noteId }),
            }).then((_res) => {
                window.location.href = "/";
            });
        }

    Then in view.py, the end point looks like. Now the request is not going to come in as a form, so you have to handle the json data structure instead. You will also need to import jsonify module as well. 

            @views.route('/delete-note', methods=['POST'])
            def delete_note():
                note = json.loads(request.data)
                noteId = data['noteId']
                note = Note.query.get(noteId)
                if note:
                    if note.user_id == current_user.id:
                        db.session.delete(note)
                        db.session.commit()
                        return jsonify({})
                return {}